# -*- coding: utf-8 -*-
"""implement bee algo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15ScrrZkZsVIR0UhZGp4CmsG1RACNw5Pa
"""

import numpy as np

# Define the fitness function to be optimized
def fitness(x):
    # Assuming x is a 2D array with columns for Cardiff Ladder Scale and GDP of a country
    # Define your fitness function here, e.g. calculate the correlation between the two columns
    corr = np.corrcoef(x[:, 0], x[:, 1])[0, 1]
    return corr

# Define the Bee Algorithm
def bee_algorithm(data, num_employed, num_onlooker, num_scout, num_iterations, patch_size):
    # Initialize the population with random solutions
    population = np.random.rand(num_employed + num_onlooker, data.shape[1])
    population[:, 0] = population[:, 0] * data[:, 0].max()  # Scale Cardiff Ladder Scale to the range of the data
    population[:, 1] = population[:, 1] * data[:, 1].max()  # Scale GDP to the range of the data
    fitness_values = np.zeros(num_employed + num_onlooker)
    for i in range(num_employed + num_onlooker):
        fitness_values[i] = fitness(data * population[i, :])
    best_solution = population[np.argmax(fitness_values), :]

    # Run the algorithm for a specified number of iterations
    for it in range(num_iterations):
        # Employed bees phase
        for i in range(num_employed):
            solution = population[i, :]
            index = np.random.randint(data.shape[1])
            solution_new = np.copy(solution)
            solution_new[index] += np.random.uniform(-patch_size, patch_size)
            solution_new[0] = np.clip(solution_new[0], data[:, 0].min(), data[:, 0].max())
            solution_new[1] = np.clip(solution_new[1], data[:, 1].min(), data[:, 1].max())
            fitness_new = fitness(data * solution_new)
            if fitness_new > fitness_values[i]:
                population[i, :] = solution_new
                fitness_values[i] = fitness_new

        # Onlooker bees phase
        fitness_probs = fitness_values / np.sum(fitness_values)
        for i in range(num_onlooker):
            index = np.random.choice(range(num_employed + num_onlooker), p=fitness_probs)
            solution = population[index, :]
            index = np.random.randint(data.shape[1])
            solution_new = np.copy(solution)
            solution_new[index] += np.random.uniform(-patch_size, patch_size)
            solution_new[0] = np.clip(solution_new[0], data[:, 0].min(), data[:, 0].max())
            solution_new[1] = np.clip(solution_new[1], data[:, 1].min(), data[:, 1].max())
            fitness_new = fitness(data * solution_new)
            if fitness_new > fitness_values[index]:
                population[index, :] = solution_new
                fitness_values[index] = fitness_new

        # Scout bees phase
        for i in range(num_scout):
            solution_new = np.random.rand(data.shape[1])
            solution_new[0] = solution_new[0] * data[:, 0].max()  # Scale Cardiff Ladder Scale to the range of the data
            solution_new[1] = solution_new[1] * data[:, 1].max()  # Scale GDP to the range of the data
            fitness_new = fitness(data * solution_new)
            if fitness_new > np.min(fitness